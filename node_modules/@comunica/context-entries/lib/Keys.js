"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeysRdfUpdateQuads = exports.KeysRdfResolveQuadPattern = exports.KeysRdfParseJsonLd = exports.KeysQueryOperation = exports.KeysInitSparql = exports.KeysHttpProxy = exports.KeysHttpMemento = exports.KeysHttp = exports.KeysCore = void 0;
var KeysCore;
(function (KeysCore) {
    /**
     * @range {Logger} A logger instance.
     */
    KeysCore["log"] = "@comunica/core:log";
})(KeysCore = exports.KeysCore || (exports.KeysCore = {}));
var KeysHttp;
(function (KeysHttp) {
    /**
     * @range {boolean} Include credentials flags.
     */
    KeysHttp["includeCredentials"] = "@comunica/bus-http:include-credentials";
    /**
     * @range {string} Authentication for a source as a "username:password"-pair.
     */
    KeysHttp["auth"] = "@comunica/bus-http:auth";
    /**
     * @range {(input: RequestInfo, init?: RequestInit) => Promise<Response>} Fetch function implementation.
     */
    KeysHttp["fetch"] = "@comunica/bus-http:fetch";
})(KeysHttp = exports.KeysHttp || (exports.KeysHttp = {}));
var KeysHttpMemento;
(function (KeysHttpMemento) {
    /**
     * @range {string} The desired datetime for Memento datetime-negotiation.
     */
    KeysHttpMemento["datetime"] = "@comunica/actor-http-memento:datetime";
})(KeysHttpMemento = exports.KeysHttpMemento || (exports.KeysHttpMemento = {}));
var KeysHttpProxy;
(function (KeysHttpProxy) {
    /**
     * @range {IProxyHandler} A handler implementing the {@link IProxyHandler} interface.
     */
    KeysHttpProxy["httpProxyHandler"] = "@comunica/actor-http-proxy:httpProxyHandler";
})(KeysHttpProxy = exports.KeysHttpProxy || (exports.KeysHttpProxy = {}));
var KeysInitSparql;
(function (KeysInitSparql) {
    /**
     * @range {Bindings} Variables that have to be pre-bound to values in the query.
     */
    KeysInitSparql["initialBindings"] = "@comunica/actor-init-sparql:initialBindings";
    /**
     * @range {string} Name of the provided query's format.
     */
    KeysInitSparql["queryFormat"] = "@comunica/actor-init-sparql:queryFormat";
    /**
     * @range {any} Which GraphQL bindings should be singularized.
     */
    KeysInitSparql["graphqlSingularizeVariables"] = "@comunica/actor-init-sparql:singularizeVariables";
    /**
     * @range {boolean} If HTTP and parsing failures are ignored.
     */
    KeysInitSparql["lenient"] = "@comunica/actor-init-sparql:lenient";
    /**
     * @range {Algebra.Operation} The original parsed query.
     */
    KeysInitSparql["query"] = "@comunica/actor-init-sparql:query";
    /**
     * @range {string} The query's base IRI.
     */
    KeysInitSparql["baseIRI"] = "@comunica/actor-init-sparql:baseIRI";
    /**
     * @range {Date} A timestamp representing the current time.
     *                 This is required for certain SPARQL operations such as NOW().
     */
    KeysInitSparql["queryTimestamp"] = "@comunica/actor-init-sparql:queryTimestamp";
    /**
     * @range {functionNamedNode: RDF.NamedNode) => ((args: RDF.Term[]) => Promise<RDF.Term>) | undefined}
     * Extension function creator for a given function IRI.
     * Returned value should be an async function implementation.
     * Undefined may be returned if no implementation exists for the given function IRI.
     *
     * The dictionary-based extensionFunctions context entry may be used instead, but not simultaneously.
     */
    KeysInitSparql["extensionFunctionCreator"] = "@comunica/actor-init-sparql:extensionFunctionCreator";
    /**
     * @range {Record<string, (args: RDF.Term[]) => Promise<RDF.Term>>} Dictionary of extension functions.
     * Key is the IRI of the function, and value is the async function implementation.
     *
     * The callback-based extensionFunctionCreator context entry may be used instead, but not simultaneously.
     */
    KeysInitSparql["extensionFunctions"] = "@comunica/actor-init-sparql:extensionFunctions";
    /**
     * @range {ICliArgsHandler[]} Enables manipulation of the CLI arguments and their processing.
     */
    KeysInitSparql["cliArgsHandlers"] = "@comunica/actor-init-sparql:cliArgsHandlers";
})(KeysInitSparql = exports.KeysInitSparql || (exports.KeysInitSparql = {}));
var KeysQueryOperation;
(function (KeysQueryOperation) {
    /**
     * @range {string} Context entry for the current query operation.
     */
    KeysQueryOperation["operation"] = "@comunica/bus-query-operation:operation";
    /**
     * @type {any} The current metadata.
     *             I.e., the metadata that was used to determine the next BGP operation.
     */
    KeysQueryOperation["bgpCurrentMetadata"] = "@comunica/bus-query-operation:bgpCurrentMetadata";
    /**
     * @range {any[]} An array of parent metadata.
     *                I.e., an array of the metadata that was present before materializing the current BGP operations.
     *                This can be passed in 'bgp' actions.
     *                The array entries should correspond to the pattern entries in the BGP.
     */
    KeysQueryOperation["bgpParentMetadata"] = "@comunica/bus-query-operation:bgpParentMetadata";
    /**
     * @range {IPatternBindings[]} Indicating which patterns were bound from variables.
     *                             I.e., an array of the same length as the value of
     *                             KeysQueryOperation.patternParentMetadata,
     *                             where each array value corresponds to the pattern bindings
     *                             for the corresponding pattern.
     */
    KeysQueryOperation["bgpPatternBindings"] = "@comunica/bus-query-operation:bgpPatternBindings";
    /**
     * @range {any} Parent metadata hash.
     *              I.e., the metadata that was present before materializing the current operation.
     *              This can be passed in 'pattern' actions.
     */
    KeysQueryOperation["patternParentMetadata"] = "@comunica/bus-query-operation:patternParentMetadata";
    /**
     * @range {boolean} Flag for indicating that only read operations are allowed, defaults to false.
     */
    KeysQueryOperation["readOnly"] = "@comunica/bus-query-operation:readOnly";
})(KeysQueryOperation = exports.KeysQueryOperation || (exports.KeysQueryOperation = {}));
var KeysRdfParseJsonLd;
(function (KeysRdfParseJsonLd) {
    /**
     * @range {IDocumentLoader}
     */
    KeysRdfParseJsonLd["documentLoader"] = "@comunica/actor-rdf-parse-jsonld:documentLoader";
    /**
     * @range {boolean}
     */
    KeysRdfParseJsonLd["strictValues"] = "@comunica/actor-rdf-parse-jsonld:strictValues";
    /**
     * @range {Record<string, any>}
     */
    KeysRdfParseJsonLd["parserOptions"] = "@comunica/actor-rdf-parse-jsonld:parserOptions";
})(KeysRdfParseJsonLd = exports.KeysRdfParseJsonLd || (exports.KeysRdfParseJsonLd = {}));
var KeysRdfResolveQuadPattern;
(function (KeysRdfResolveQuadPattern) {
    /**
     * @range {DataSources} Data sources.
     */
    KeysRdfResolveQuadPattern["sources"] = "@comunica/bus-rdf-resolve-quad-pattern:sources";
    /**
     * @range {IDataSource} A data source.
     */
    KeysRdfResolveQuadPattern["source"] = "@comunica/bus-rdf-resolve-quad-pattern:source";
})(KeysRdfResolveQuadPattern = exports.KeysRdfResolveQuadPattern || (exports.KeysRdfResolveQuadPattern = {}));
var KeysRdfUpdateQuads;
(function (KeysRdfUpdateQuads) {
    /**
     * @range {IDataDestination} A data destination.
     */
    KeysRdfUpdateQuads["destination"] = "@comunica/bus-rdf-update-quads:destination";
})(KeysRdfUpdateQuads = exports.KeysRdfUpdateQuads || (exports.KeysRdfUpdateQuads = {}));
//# sourceMappingURL=Keys.js.map